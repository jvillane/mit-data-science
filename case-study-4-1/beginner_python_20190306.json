{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {
    "collapsed": true
   },
   "source": [
    "# Case Study 4.1 - Movies"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "<h1 style=\"color:red;\">Note: If you close this notebook at any time, you will have to run all cells again upon re-opening it.</h1>"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# BEGINNER PYTHON"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "As this is a beginner version, we include a lot of code here to help you along the way."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Identification Information"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 1,
   "metadata": {
    "trusted": true
   },
   "outputs": [],
   "source": [
    "# YOUR NAME              = Julio Villane\n",
    "# YOUR MITX PRO USERNAME = jvillane\n",
    "# YOUR MITX PRO E-MAIL   = jvillane@gmail.com"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Setup"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Run these cells to install all the packages you need to complete the remainder of the case study. This may take a few minutes, so please be patient."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "metadata": {
    "trusted": true
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Collecting surprise==0.1\n  Using cached https://files.pythonhosted.org/packages/61/de/e5cba8682201fcf9c3719a6fdda95693468ed061945493dea2dd37c5618b/surprise-0.1-py2.py3-none-any.whl\nCollecting scikit-surprise (from surprise==0.1)\n\u001b[?25l  Downloading https://files.pythonhosted.org/packages/4d/fc/cd4210b247d1dca421c25994740cbbf03c5e980e31881f10eaddf45fdab0/scikit-surprise-1.0.6.tar.gz (3.3MB)\n\u001b[K    100% |████████████████████████████████| 3.3MB 191kB/s eta 0:00:01\n\u001b[?25hRequirement already satisfied: joblib>=0.11 in /home/nbuser/anaconda3_501/lib/python3.6/site-packages (from scikit-surprise->surprise==0.1) (0.12.5)\nRequirement already satisfied: numpy>=1.11.2 in /home/nbuser/anaconda3_501/lib/python3.6/site-packages (from scikit-surprise->surprise==0.1) (1.14.6)\nRequirement already satisfied: scipy>=1.0.0 in /home/nbuser/anaconda3_501/lib/python3.6/site-packages (from scikit-surprise->surprise==0.1) (1.1.0)\nRequirement already satisfied: six>=1.10.0 in /home/nbuser/anaconda3_501/lib/python3.6/site-packages (from scikit-surprise->surprise==0.1) (1.11.0)\nBuilding wheels for collected packages: scikit-surprise\n  Building wheel for scikit-surprise (setup.py) ... \u001b[?25ldone\n\u001b[?25h  Stored in directory: /home/nbuser/.cache/pip/wheels/ec/c0/55/3a28eab06b53c220015063ebbdb81213cd3dcbb72c088251ec\nSuccessfully built scikit-surprise\nInstalling collected packages: scikit-surprise, surprise\nSuccessfully installed scikit-surprise-1.0.6 surprise-0.1\n"
     ]
    }
   ],
   "source": [
    "!pip install surprise==0.1"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Now, you must press **Kernel > Restart.** This allows the installation to take effect. Once you see the blue **Connected/Kernel ready** button in the top right, you are good to go."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Import"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Import the required tools into the notebook."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "metadata": {
    "trusted": true
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Imports successful!\n"
     ]
    }
   ],
   "source": [
    "import pandas as pd\n",
    "import matplotlib\n",
    "from surprise import Dataset, SVD, NormalPredictor, BaselineOnly, KNNBasic, NMF\n",
    "from surprise.model_selection import cross_validate, KFold\n",
    "print('Imports successful!')"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "metadata": {
    "trusted": true
   },
   "outputs": [],
   "source": [
    "%matplotlib inline"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Data"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Load the MovieLens data. A dialog may pop up saying **\"Dataset ml-100k could not be found. Do you want to download it? [Y/n]\"** Type Y and hit Enter to start the download process."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "metadata": {
    "trusted": true
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Data load successful!\n"
     ]
    }
   ],
   "source": [
    "data = Dataset.load_builtin('ml-100k')\n",
    "print('Data load successful!')"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "We also want to get a sense of what the data looks like. Let's create a histogram of all the ratings we have in the dataset."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 6,
   "metadata": {
    "trusted": true
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Histogram generation successful!\n"
     ]
    },
    {
     "data": {
      "image/png": "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\n",
      "text/plain": [
       "<Figure size 432x288 with 1 Axes>"
      ]
     },
     "metadata": {
      "needs_background": "light"
     },
     "output_type": "display_data"
    }
   ],
   "source": [
    "# 1. Get the ratings file from the data object\n",
    "# This is just a filename that has all the data stored in it\n",
    "ratings_file = data.ratings_file\n",
    "\n",
    "# 2. Load that table using pandas, a commmon python data loading tool\n",
    "# We set the column names manually here\n",
    "col_names = ['user_id', 'item_id', 'rating', 'timestamp']\n",
    "raw_data = pd.read_table(ratings_file, names=col_names)\n",
    "\n",
    "# 3. Get the rating column\n",
    "ratings = raw_data.rating\n",
    "\n",
    "# 4. Generate a bar plot/histogram of that data\n",
    "ratings.value_counts().sort_index().plot.bar()\n",
    "\n",
    "print('Histogram generation successful!')"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "<h1 style=\"color:red;\">QUESTION 1: DATA ANALYSIS</h1>"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "**Describe the dataset. How many ratings are in the dataset? How would you describe the distribution of ratings? Is there anything else we should observe? Make sure the histogram is visible in the notebook.**"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 15,
   "metadata": {
    "trusted": true
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Number of ratings per user...\n"
     ]
    },
    {
     "data": {
      "text/plain": [
       "<matplotlib.axes._subplots.AxesSubplot at 0x7f4fddda2438>"
      ]
     },
     "execution_count": 15,
     "metadata": {},
     "output_type": "execute_result"
    },
    {
     "data": {
      "image/png": "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\n",
      "text/plain": [
       "<Figure size 432x288 with 1 Axes>"
      ]
     },
     "metadata": {
      "needs_background": "light"
     },
     "output_type": "display_data"
    }
   ],
   "source": [
    "user_ids = raw_data.user_id\n",
    "print('Number of ratings per user...')\n",
    "user_ids.value_counts().plot(kind='bar', label='Number of ratings per user')"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 16,
   "metadata": {
    "trusted": true
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Number of ratings per movie...\n"
     ]
    },
    {
     "data": {
      "text/plain": [
       "<matplotlib.axes._subplots.AxesSubplot at 0x7f4fdc5da940>"
      ]
     },
     "execution_count": 16,
     "metadata": {},
     "output_type": "execute_result"
    },
    {
     "data": {
      "image/png": "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\n",
      "text/plain": [
       "<Figure size 432x288 with 1 Axes>"
      ]
     },
     "metadata": {
      "needs_background": "light"
     },
     "output_type": "display_data"
    }
   ],
   "source": [
    "item_ids = raw_data.item_id\n",
    "print('Number of ratings per movie...')\n",
    "item_ids.value_counts().plot(kind='bar', label='Number of ratings per movie')"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "There size of the dataset is 100.000.\nAs you can see in the 'Number of ratings per user' graph, some users rated a large amount of movies (more than 400 in some cases) and, in the other hand, other users rated less than 10 movies.\nSomething similar happen in the 'Number of ratings per movie' graph, some movies were rated by a lot of users (more than 300 in some cases) and, in the other hand, other movies were rated less than 10 times.\nBoth graphs are visually consistent with poisson distribution or exponential distribution"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Model 1: Random"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 17,
   "metadata": {
    "trusted": true
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Model creation successful!\n"
     ]
    }
   ],
   "source": [
    "# Create model object\n",
    "model_random = NormalPredictor()\n",
    "print('Model creation successful!')"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 18,
   "metadata": {
    "trusted": true
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Evaluating RMSE of algorithm NormalPredictor on 5 split(s).\n\n                  Fold 1  Fold 2  Fold 3  Fold 4  Fold 5  Mean    Std     \nRMSE (testset)    1.5145  1.5302  1.5173  1.5251  1.5213  1.5217  0.0056  \nFit time          0.75    0.90    0.99    0.93    0.82    0.88    0.08    \nTest time         1.08    1.00    1.00    0.95    0.92    0.99    0.05    \nModel training successful!\n"
     ]
    }
   ],
   "source": [
    "# Train on data using cross-validation with k=5 folds, measuring the RMSE\n",
    "model_random_results = cross_validate(model_random, data, measures=['RMSE'], cv=5, verbose=True)\n",
    "print('Model training successful!')"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Model 2: User-Based Collaborative Filtering"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 19,
   "metadata": {
    "trusted": true
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Model creation successful!\n"
     ]
    }
   ],
   "source": [
    "# Create model object\n",
    "model_user = KNNBasic(sim_options={'user_based': True})\n",
    "print('Model creation successful!')"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 20,
   "metadata": {
    "trusted": true
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Computing the msd similarity matrix...\nDone computing similarity matrix.\nComputing the msd similarity matrix...\nDone computing similarity matrix.\nComputing the msd similarity matrix...\nDone computing similarity matrix.\nComputing the msd similarity matrix...\nDone computing similarity matrix.\nComputing the msd similarity matrix...\nDone computing similarity matrix.\nEvaluating RMSE of algorithm KNNBasic on 5 split(s).\n\n                  Fold 1  Fold 2  Fold 3  Fold 4  Fold 5  Mean    Std     \nRMSE (testset)    0.9752  0.9830  0.9828  0.9820  0.9780  0.9802  0.0031  \nFit time          1.92    2.10    2.14    2.18    2.15    2.10    0.09    \nTest time         23.44   24.36   23.12   22.11   22.73   23.15   0.75    \nModel training successful!\n"
     ]
    }
   ],
   "source": [
    "# Train on data using cross-validation with k=5 folds, measuring the RMSE\n",
    "# Note, this may have a lot of print output\n",
    "# You can set verbose=False to prevent this from happening\n",
    "model_user_results = cross_validate(model_user, data, measures=['RMSE'], cv=5, verbose=True)\n",
    "print('Model training successful!')"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Model 3: Item-Based Collaborative Filtering"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 21,
   "metadata": {
    "trusted": true
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Model creation successful!\n"
     ]
    }
   ],
   "source": [
    "# Create model object\n",
    "model_item = KNNBasic(sim_options={'user_based': False})\n",
    "print('Model creation successful!')"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 22,
   "metadata": {
    "trusted": true
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Computing the msd similarity matrix...\nDone computing similarity matrix.\nComputing the msd similarity matrix...\nDone computing similarity matrix.\nComputing the msd similarity matrix...\nDone computing similarity matrix.\nComputing the msd similarity matrix...\nDone computing similarity matrix.\nComputing the msd similarity matrix...\nDone computing similarity matrix.\nEvaluating RMSE of algorithm KNNBasic on 5 split(s).\n\n                  Fold 1  Fold 2  Fold 3  Fold 4  Fold 5  Mean    Std     \nRMSE (testset)    0.9755  0.9681  0.9737  0.9809  0.9713  0.9739  0.0043  \nFit time          3.07    3.35    3.45    3.42    3.43    3.35    0.14    \nTest time         26.12   25.61   27.55   25.96   26.06   26.26   0.67    \nModel training successful!\n"
     ]
    }
   ],
   "source": [
    "# Train on data using cross-validation with k=5 folds, measuring the RMSE\n",
    "# Note, this may have a lot of print output\n",
    "# You can set verbose=False to prevent this from happening\n",
    "model_item_results = cross_validate(model_item, data, measures=['RMSE'], cv=5, verbose=True)\n",
    "print('Model training successful!')"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "<h1 style=\"color:red;\">QUESTION 2: COLLABORATIVE FILTERING MODELS</h1>"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "**Compare the results from the user-user and item-item models. How do they compare to each other? How do they compare to our original \"random\" model? Can you provide any intuition as to why the results came out the way they did?**"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Considering the RMSE mean results of each model with the same data, the User-Based and Item-Based Collaborative Filtering models had a better fit than the baseline Random Model, so both models (2 and 3) are better response predictors than a random one.\n\nIf we analize the User-Based with Item-Based Collaborative Filtering models, there is a little difference between their corresponding RMSE mean (0.9802 and 0.9739 respectively). So, it's reasonable to affirm that the Item-Based Collaborative Filtering model works better than the User-Based Collaborative Filtering model.\n\nMaybe, the main reason that explains the better fit for the Item-Based Collaborative Filtering model, is that there is an easier way of calculate similarity between items rather than users, because when the movie is popular that induce that a lot of users rated it, and those movies (the popular ones) are the ones that really matter.\n\n--- The item based personalization is much more predictive than the user based ones. For exactly the reason that we mentioned before. The movies that really matter have a lot of ratings."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Model 4: Matrix Factorization"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 23,
   "metadata": {
    "trusted": true
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Model creation successful!\n"
     ]
    }
   ],
   "source": [
    "# Create model object\n",
    "model_matrix = SVD()\n",
    "print('Model creation successful!')"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 24,
   "metadata": {
    "trusted": true,
    "scrolled": true
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Evaluating RMSE of algorithm SVD on 5 split(s).\n\n                  Fold 1  Fold 2  Fold 3  Fold 4  Fold 5  Mean    Std     \nRMSE (testset)    0.9279  0.9373  0.9330  0.9343  0.9391  0.9343  0.0039  \nFit time          30.55   31.76   29.66   30.74   31.80   30.90   0.80    \nTest time         1.18    1.01    3.29    1.15    1.12    1.55    0.87    \nModel training successful!\n"
     ]
    }
   ],
   "source": [
    "# Train on data using cross-validation with k=5 folds, measuring the RMSE\n",
    "# Note, this may take some time (2-3 minutes) to train, so please be patient\n",
    "model_matrix_results = cross_validate(model_matrix, data, measures=['RMSE'], cv=5, verbose=True)\n",
    "print('Model training successful!')"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "<h1 style=\"color:red;\">QUESTION 3: MATRIX FACTORIZATION MODEL</h1>"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "**The matrix factorization model is different from the collaborative filtering models. Briefly describe this difference. Also, compare the RMSE again. Does it improve? Can you offer any reasoning as to why that might be?**"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "The Collaborative Filtering Models consider that exists a relation (or similarity) between the users (rows) or the items (columns). In the case of the users, it's reasonably to assume that some groups of users share the same preferences for different groups of movies (love, action, drama, etc)... they are correlated. With that in mind, use that information to predict a rating based on how well that user is represented by a defined group of users with their rating values. Something similar happens with movies.\n\nOn the other hand, Matrix Factorization models extracts the relation between rows and columns at the same time by defining a group of features that will be used to represent those relations, so it's reasonable that the predictions made by this model would be better than the predictions made by the previously mentioned Collaborative Filter models (mean RMSE of 0.9343)."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Precision and Recall @ `k`"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "We now want to compute the precision and recall for 2 values of `k`: 5 and 10. We have provided some code here to help you do that."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "First, we define a function that takes in some predictions, a value of `k` and a threshold parameter. This code is adapted from [here](http://surprise.readthedocs.io/en/stable/FAQ.html?highlight=precision#how-to-compute-precision-k-and-recall-k). **Make sure you run this cell.**"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 25,
   "metadata": {
    "trusted": true
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Function creation successful!\n"
     ]
    }
   ],
   "source": [
    "def precision_recall_at_k(predictions, k=10, threshold=3.5):\n",
    "    '''Return precision and recall at k metrics for each user.'''\n",
    "\n",
    "    # First map the predictions to each user.\n",
    "    user_est_true = dict()\n",
    "    for uid, _, true_r, est, _ in predictions:\n",
    "        current = user_est_true.get(uid, list())\n",
    "        current.append((est, true_r))\n",
    "        user_est_true[uid] = current\n",
    "\n",
    "    precisions = dict()\n",
    "    recalls = dict()\n",
    "    for uid, user_ratings in user_est_true.items():\n",
    "\n",
    "        # Sort user ratings by estimated value\n",
    "        user_ratings.sort(key=lambda x: x[0], reverse=True)\n",
    "\n",
    "        # Number of relevant items\n",
    "        n_rel = sum((true_r >= threshold) for (_, true_r) in user_ratings)\n",
    "\n",
    "        # Number of recommended items in top k\n",
    "        n_rec_k = sum((est >= threshold) for (est, _) in user_ratings[:k])\n",
    "\n",
    "        # Number of relevant and recommended items in top k\n",
    "        n_rel_and_rec_k = sum(((true_r >= threshold) and (est >= threshold))\n",
    "                              for (est, true_r) in user_ratings[:k])\n",
    "\n",
    "        # Precision@K: Proportion of recommended items that are relevant\n",
    "        precisions[uid] = n_rel_and_rec_k / n_rec_k if n_rec_k != 0 else 1\n",
    "\n",
    "        # Recall@K: Proportion of relevant items that are recommended\n",
    "        recalls[uid] = n_rel_and_rec_k / n_rel if n_rel != 0 else 1\n",
    "\n",
    "    return precisions, recalls\n",
    "\n",
    "print('Function creation successful!')"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Next, we compute the precision and recall at `k` = 5 and 10 for each of our 4 models. We use 5-fold cross validation again to average the results across the entire dataseat.\n\nPlease note that this will take some time to compute."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "<h1 style=\"color:red;\">QUESTION 4: PRECISION/RECALL</h1>"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "**Compute the precision and recall, for each of the 4 models, at `k` = 5 and 10. This is 2 x 2 x 4 = 16 numerical values. Do you note anything interesting about these values? Anything differerent from the RMSE values you computed above?**"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Precision/Recall Table\n![recall_precision.png](attachment:recall_precision.png)\n\nAs you can appreciate on the table results, as expected the Random Model is the worst performed model, so I won't analyze those values.\n\nOn the other hand, we can note from the results that the User based model has consistently better Recall than the other models, and the Item based model has consistenly better Precision than the other models. These results are not \n\nComputing the F1 Score we obtain the following values:\n![f1_score.png](attachment:f1_score.png)\n\nIn the table we can appreciate something different from the RMSE results, in this case, the best performed model is the User-based model, followed by the Matrix Factorization"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 26,
   "metadata": {
    "trusted": true
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      ">>> k=5, model=NormalPredictor\n>>> precision: 0.588\n>>> reccall  : 0.338\n\n\n>>> k=5, model=KNNBasic\nComputing the msd similarity matrix...\nDone computing similarity matrix.\nComputing the msd similarity matrix...\nDone computing similarity matrix.\nComputing the msd similarity matrix...\nDone computing similarity matrix.\nComputing the msd similarity matrix...\nDone computing similarity matrix.\nComputing the msd similarity matrix...\nDone computing similarity matrix.\n>>> precision: 0.764\n>>> reccall  : 0.457\n\n\n>>> k=5, model=KNNBasic\nComputing the msd similarity matrix...\nDone computing similarity matrix.\nComputing the msd similarity matrix...\nDone computing similarity matrix.\nComputing the msd similarity matrix...\nDone computing similarity matrix.\nComputing the msd similarity matrix...\nDone computing similarity matrix.\nComputing the msd similarity matrix...\nDone computing similarity matrix.\n>>> precision: 0.82\n>>> reccall  : 0.392\n\n\n>>> k=5, model=SVD\n>>> precision: 0.783\n>>> reccall  : 0.433\n\n\n>>> k=10, model=NormalPredictor\n>>> precision: 0.586\n>>> reccall  : 0.427\n\n\n>>> k=10, model=KNNBasic\nComputing the msd similarity matrix...\nDone computing similarity matrix.\nComputing the msd similarity matrix...\nDone computing similarity matrix.\nComputing the msd similarity matrix...\nDone computing similarity matrix.\nComputing the msd similarity matrix...\nDone computing similarity matrix.\nComputing the msd similarity matrix...\nDone computing similarity matrix.\n>>> precision: 0.738\n>>> reccall  : 0.591\n\n\n>>> k=10, model=KNNBasic\nComputing the msd similarity matrix...\nDone computing similarity matrix.\nComputing the msd similarity matrix...\nDone computing similarity matrix.\nComputing the msd similarity matrix...\nDone computing similarity matrix.\nComputing the msd similarity matrix...\nDone computing similarity matrix.\nComputing the msd similarity matrix...\nDone computing similarity matrix.\n>>> precision: 0.789\n>>> reccall  : 0.531\n\n\n>>> k=10, model=SVD\n>>> precision: 0.755\n>>> reccall  : 0.561\n\n\nPrecision and recall computation successful!\n"
     ]
    }
   ],
   "source": [
    "# Make list of k values\n",
    "K = [5, 10]\n",
    "\n",
    "# Make list of models\n",
    "models = [model_random, model_user, model_item, model_matrix]\n",
    "\n",
    "# Create k-fold cross validation object\n",
    "kf = KFold(n_splits=5)\n",
    "\n",
    "for k in K:\n",
    "    for model in models:\n",
    "        print(f'>>> k={k}, model={model.__class__.__name__}')\n",
    "        # Run folder and take average\n",
    "        p = []\n",
    "        r = []\n",
    "        for trainset, testset in kf.split(data):\n",
    "            model.fit(trainset)\n",
    "            predictions = model.test(testset, verbose=False)\n",
    "            precisions, recalls = precision_recall_at_k(predictions, k=k, threshold=3.5)\n",
    "\n",
    "            # Precision and recall can then be averaged over all users\n",
    "            p.append(sum(prec for prec in precisions.values()) / len(precisions))\n",
    "            r.append(sum(rec for rec in recalls.values()) / len(recalls))\n",
    "        \n",
    "        print('>>> precision:', round(sum(p) / len(p), 3))\n",
    "        print('>>> reccall  :', round(sum(r) / len(r), 3))\n",
    "        print('\\n')\n",
    "\n",
    "print('Precision and recall computation successful!')"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "#  Top-`n` Predictions"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Finally, we can see what some of the actual movie ratings are for particular users, as outputs of our model."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Again, we define a helpful function."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 57,
   "metadata": {
    "trusted": true
   },
   "outputs": [],
   "source": [
    "def get_top_n(predictions, n=5):\n",
    "    '''Return the top-N recommendation for each user from a set of predictions.\n",
    "\n",
    "    Args:\n",
    "        predictions(list of Prediction objects): The list of predictions, as\n",
    "            returned by the test method of an algorithm.\n",
    "        n(int): The number of recommendation to output for each user. Default\n",
    "            is 10.\n",
    "\n",
    "    Returns:\n",
    "    A dict where keys are user (raw) ids and values are lists of tuples:\n",
    "        [(raw item id, rating estimation), ...] of size n.\n",
    "    '''\n",
    "\n",
    "    # First map the predictions to each user.\n",
    "    top_n = dict()\n",
    "    for uid, iid, true_r, est, _ in predictions:\n",
    "        current = top_n.get(uid, [])\n",
    "        current.append((iid, est))\n",
    "        top_n[uid] = current\n",
    "\n",
    "    # Then sort the predictions for each user and retrieve the k highest ones.\n",
    "    for uid, user_ratings in top_n.items():\n",
    "        user_ratings.sort(key=lambda x: x[1], reverse=True)\n",
    "        top_n[uid] = user_ratings[:n]\n",
    "\n",
    "    return top_n\n",
    "\n",
    "print('Function creation successful!')"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Then, we call this function on each of our models, first training on **all** the data we have available, then predicting on the remaining, missing data. We use `n`=5 here, but you can pick any reasonable value of `n` you would like.\n\nThis may take some time to compute, so be patient."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 27,
   "metadata": {
    "trusted": true,
    "collapsed": false
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Trainset and testset creation successful!\n"
     ]
    }
   ],
   "source": [
    "trainset = data.build_full_trainset()\n",
    "testset = trainset.build_anti_testset()\n",
    "print('Trainset and testset creation successful!')"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "<h1 style=\"color:red;\">QUESTION 5: TOP N PREDICTIONS</h1>"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "**Do the top n predictions that you received make sense? What is the rating value (1-5) of these predictions? How could you use these predictions in the real-world if you were trying to build a generic content recommender system for a company?**"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "*Type your response here...*"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "trusted": true
   },
   "outputs": [],
   "source": [
    "for model in models:\n",
    "    model.fit(trainset)\n",
    "    predictions = model.test(testset)\n",
    "    top_n = get_top_n(predictions, n=5)\n",
    "    # Print the first one\n",
    "    user = list(top_n.keys())[0]\n",
    "    print(f'model: {model}, {user}: {top_n[user]}')\n",
    "\n",
    "print('Top N computation successful!')"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "<hr>"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Great job! Now, make sure you check out the **Conclusion** section of the [instruction manual](https://courses.edx.org/asset-v1:MITxPRO+DSx+2T2018+type@asset+block@4.1_instruction_manual.html) to wrap up this case study properly."
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "name": "python36",
   "display_name": "Python 3.6",
   "language": "python"
  },
  "language_info": {
   "mimetype": "text/x-python",
   "nbconvert_exporter": "python",
   "name": "python",
   "pygments_lexer": "ipython3",
   "version": "3.6.6",
   "file_extension": ".py",
   "codemirror_mode": {
    "version": 3,
    "name": "ipython"
   }
  }
 },
 "nbformat": 4,
 "nbformat_minor": 2
}
